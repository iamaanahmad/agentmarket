AWS Global Vibe: AI Coding Hackathon 2025 - Complete Project Brief
HACKATHON OVERVIEW
Event Details
Name: AWS Global Vibe: AI Coding Hackathon 2025

Organizer: DoraHacks + Amazon Web Services

Prize Pool: $700,000+ USD

Submission Deadline: December 1, 2025, 11:59 PM PST

Announcement Date: December 2025

Format: Global, online hackathon

Mandatory Requirements
Must use: Amazon Q Developer OR Kiro IDE (we're using Kiro IDE)

Must submit: Working demo with video demonstration

Must show: .kiro folder structure with specs (requirements.md, design.md, tasks.md)

Must deploy: Functional application (testnet acceptable, mainnet preferred)

Must document: AWS Q Developer or Kiro IDE usage throughout development

WEB3 AI INTEGRATION TRACK - REQUIREMENTS
Track Description
Build innovative applications that combine Web3 blockchain technology with AI capabilities. Projects should demonstrate seamless integration of autonomous AI agents, smart contracts, and decentralized infrastructure.

Track-Specific Requirements
âœ… Blockchain Integration: Must use at least one blockchain network (Solana preferred)
âœ… AI Component: Must include autonomous AI agents or machine learning capabilities
âœ… Real-world Utility: Must solve actual Web3 user problems
âœ… Smart Contracts: Must include on-chain logic (registry, payments, governance, etc.)
âœ… Web3 Wallet Integration: Must support wallet connection (Phantom, Solflare, etc.)

Judging Criteria (Weighted)
1. Technological Implementation (25%)
Quality of code and software architecture

Proper integration of AI and Web3 technologies

Security and error handling

Scalability considerations

Use of best practices

2. Potential Value (20%)
Usefulness to target users

Ease of use and accessibility

Clear value proposition

Size of addressable market

3. Kiro IDE Implementation (20%)
Effective use of spec-driven development

Complete .kiro folder structure

Quality of requirements.md, design.md, tasks.md

Documentation of AWS Q Developer integration

Evidence of Kiro IDE throughout development

4. Quality of Idea (15%)
Creativity and originality

Uniqueness in the ecosystem

Innovation beyond existing solutions

Future-forward thinking

5. Design & User Experience (10%)
Interface design quality

User experience flow

Accessibility

Mobile responsiveness

6. Potential Impact (10%)
Open-source contribution value

Impact on blockchain and AI ecosystem

Community benefit

Ecosystem growth potential

7. Project Sustainability (10%)
Long-term viability

Realistic roadmap

Business model clarity

Path to adoption

Technical Stack Recommendations
Blockchain: Solana (preferred), Ethereum, Polygon

AI/ML: Claude API, GPT-4, Hugging Face models, LangChain

Development: Kiro IDE with AWS Q Developer

Smart Contracts: Anchor (Solana), Solidity (Ethereum)

Frontend: Next.js, React, TypeScript

Deployment: AWS Amplify, AWS Lambda, Vercel

OUR PROJECT: AgentMarket
Project Tagline
"The First Decentralized Marketplace Where AI Agents Earn, Humans Prosper, and Innovation is Rewarded"

One-Line Description
A Web3-powered marketplace platform where autonomous AI agents offer services for crypto micropayments, with SecurityGuard AI as the flagship agent protecting users from blockchain exploits.

Problem Statement
Problem 1: No Trusted AI Agent Marketplace

AI agent economy is exploding ($637M raised in 2025)

Creators have no easy way to monetize AI models/agents

Users have no trusted platform to discover and hire AI services

Current platforms charge 20-30% fees with payment delays

Problem 2: Web3 Security Crisis

$2 billion lost to wallet exploits in 2024

Users lack real-time protection before signing transactions

Complex security tools intimidate newcomers

No AI-powered transaction analysis available

Problem 3: Web3 Accessibility Barrier

65% of new Web3 users abandon within first month

Technical complexity prevents mass adoption

No natural language interface for blockchain operations

High barrier to entry for non-technical users

Our Solution: Two-Pronged Approach
Core Platform: AgentMarket
A decentralized marketplace where:

Creators register AI agents as on-chain NFTs

Users discover and hire agents with crypto micropayments

Smart contracts enforce fair payment and royalty splits

Reputation system ensures quality and trust

Anyone can participate without intermediaries

Launch Agent: SecurityGuard AI
A flagship AI agent that:

Scans transactions before signing (real-time protection)

Detects wallet drainers, rug pulls, malicious contracts

Explains risks in natural language

Charges 0.01 SOL per scan (~$2)

Proves marketplace utility from day one

DETAILED PROJECT ARCHITECTURE
System Components Overview
text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    USER INTERFACE                        â”‚
â”‚  (Next.js + Wallet Integration + Natural Language)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              APPLICATION LAYER                           â”‚
â”‚  â€¢ Agent Discovery & Search                             â”‚
â”‚  â€¢ Service Request Management                           â”‚
â”‚  â€¢ Payment Processing                                   â”‚
â”‚  â€¢ Creator Dashboard                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              SMART CONTRACT LAYER (Solana)              â”‚
â”‚  â€¢ Agent Registry Contract                              â”‚
â”‚  â€¢ Escrow Payment Contract                              â”‚
â”‚  â€¢ Reputation System Contract                           â”‚
â”‚  â€¢ Royalty Distribution Contract                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              AI AGENT LAYER                             â”‚
â”‚  â€¢ SecurityGuard AI (Transaction Scanner)               â”‚
â”‚  â€¢ Agent Orchestrator                                   â”‚
â”‚  â€¢ Natural Language Processor                           â”‚
â”‚  â€¢ Result Validator                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Technology Stack Details
Frontend Layer
Framework: Next.js 14 (App Router with TypeScript)

Styling: TailwindCSS + shadcn/ui components

State Management: React Query + Zustand

Web3 Integration:

@solana/wallet-adapter-react

@solana/wallet-adapter-wallets (Phantom, Solflare, Backpack)

@solana/web3.js

Charts: Recharts for analytics dashboards

Forms: React Hook Form + Zod validation

Smart Contract Layer
Framework: Anchor 0.30+ (Solana)

Language: Rust

Programs:

agent_registry: Agent registration, metadata storage

marketplace_escrow: Payment holding and release

reputation_system: On-chain ratings and reviews

royalty_splitter: Automated payment distribution

Token Standard: Metaplex NFT for agent ownership

AI Agent Layer
Primary AI: Claude Sonnet 4 (via Anthropic API)

Security Analysis: Custom ML model trained on exploit patterns

NLP Interface: Fine-tuned model for Web3 terminology

Orchestration: LangChain for agent workflow management

Vector DB: Pinecone for semantic search of agents

Backend Services
API Framework: Next.js API Routes + FastAPI (Python for AI)

Database: PostgreSQL (AWS RDS) for off-chain data

User profiles and preferences

Service request history

Analytics and metrics

Agent metadata cache

Caching: Redis (AWS ElastiCache) for performance

Storage:

IPFS for agent code/models (decentralized)

AWS S3 for media assets

Infrastructure & DevOps
Development: Kiro IDE with AWS Q Developer integration

Frontend Hosting: AWS Amplify

Backend Functions: AWS Lambda (serverless)

Database: Amazon RDS (PostgreSQL)

Monitoring: AWS CloudWatch + Sentry

CI/CD: GitHub Actions

RPC Provider: Helius (Solana)

COMPLETE FEATURE SPECIFICATIONS
Phase 1: Core Marketplace (MVP)
Feature 1: Agent Registration
As a AI agent creator
I want to register my agent on-chain with capabilities and pricing
So that users can discover and hire my agent while I earn royalties

Technical Implementation:

Creator connects wallet (Phantom/Solflare)

Fills registration form:

Agent name and description

Capabilities (checkboxes: Security, Code Gen, Analysis, etc.)

Pricing model (per-query, subscription, custom)

Agent endpoint URL (for execution)

IPFS hash of agent code/model

Smart contract mints agent NFT to creator

Agent appears in marketplace within 5 seconds

Creator dashboard shows agent status

Acceptance Criteria:

 Agent metadata stored on-chain (Solana)

 NFT minted to creator wallet

 Agent searchable in marketplace immediately

 Creator can update agent metadata

 Gas fees under 0.01 SOL

Feature 2: Agent Discovery & Search
As a platform user
I want to search and filter AI agents by capability
So that I can find the right agent for my task

Technical Implementation:

Marketplace page displays all agents (grid/list view)

Search bar with real-time filtering

Filters:

Capability type (Security, Code, Design, etc.)

Price range (SOL)

Rating (1-5 stars)

Sort by: Popular, Newest, Highest Rated, Cheapest

Agent cards show:

Name, creator, capability badges

Price, rating, total uses

"View Profile" and "Hire Now" buttons

Pagination (20 agents per page)

Acceptance Criteria:

 Search results return in <500ms

 Filters work correctly

 Mobile responsive design

 Agent profiles load instantly

 Handles 100+ agents smoothly

Feature 3: Service Request & Escrow Payment
As a platform user
I want to hire an AI agent and pay with crypto
So that I can complete my task without traditional payment friction

Technical Implementation:

User clicks "Hire Agent"

Modal opens with:

Service description input

Price display (in SOL + USD)

"Confirm & Pay" button

User confirms â†’ Wallet prompts transaction

Smart contract:

Transfers SOL to escrow account

Creates service request record

Notifies agent endpoint (webhook)

Agent processes request

Agent submits result to contract

User reviews result:

"Accept" â†’ Releases payment (85% creator, 10% platform, 5% treasury)

"Dispute" â†’ Triggers manual review

Status tracking page shows progress

Acceptance Criteria:

 Escrow holds payment securely

 Agent receives webhook notification

 Result delivered to user interface

 Payment splits correctly (85/10/5)

 Entire flow completes in <2 minutes (for fast agents)

 User can track status in real-time

Feature 4: Reputation System
As a platform user
I want to rate agents after service completion
So that I can help others make informed hiring decisions

Technical Implementation:

After service completion, rating modal appears

User provides:

Star rating (1-5)

Optional text review (stored on-chain or IPFS)

Quality, Speed, Value ratings

Smart contract:

Records rating on-chain

Updates agent's average rating

Increments total service count

Agent profile displays:

Overall rating (e.g., 4.7/5.0)

Total services completed

Rating distribution histogram

Recent reviews

Acceptance Criteria:

 Ratings stored permanently on-chain

 Average calculated correctly

 Only paying users can rate

 One rating per service request

 Agent ranking reflects reputation

Feature 5: Creator Dashboard
As an agent creator
I want to view my agent's performance and earnings
So that I can track success and optimize my offerings

Technical Implementation:

Dashboard accessible from navbar

Displays:

Earnings Card: Total earned, available to withdraw, chart

Performance Metrics: Total requests, success rate, avg rating

Request History: Recent jobs with status

Analytics: Usage over time, popular request types

Withdraw Button: Transfer earnings to wallet

Real-time updates via WebSocket

Export data as CSV

Acceptance Criteria:

 Earnings displayed accurately

 Withdraw function works (transfers SOL to wallet)

 Charts show meaningful data

 Mobile responsive

 Updates in real-time

Phase 2: SecurityGuard AI Agent
Feature 6: Transaction Security Scanning
As a Solana wallet user
I want AI-powered transaction analysis before signing
So that I can avoid malicious contracts and protect my assets

Technical Implementation:

User initiates transaction (any Solana dApp)

Before signing, user copies transaction data

User goes to AgentMarket â†’ SecurityGuard page

Pastes transaction data â†’ Clicks "Scan Now"

SecurityGuard AI:

Parses transaction instructions

Identifies program IDs and accounts

Checks against exploit database (10M+ patterns)

Runs ML model for anomaly detection

Analyzes account permissions (token approvals, authority changes)

Generates risk score (0-100)

Returns result in <2 seconds:

Risk Level: SAFE / CAUTION / DANGER

Risk Score: 95/100 (High risk)

Explanation: "This contract will drain your wallet. It requests unlimited token approval and transfers to unknown address."

Recommendation: BLOCK / PROCEED WITH CAUTION / SAFE TO SIGN

User pays 0.01 SOL per scan

History saved in user dashboard

Acceptance Criteria:

 Analyzes transactions in <2 seconds

 Detects known exploit patterns (99%+ accuracy)

 Explains risks in simple language

 Works with all Solana dApps

 Payment processed automatically

 False positive rate <1%

Feature 7: Natural Language Security Interface
As a non-technical user
I want to ask security questions in plain English
So that I can understand Web3 risks without technical knowledge

Technical Implementation:

Chat interface on SecurityGuard page

User types questions like:

"Is this NFT mint safe?"

"Should I trust this new token?"

"What does this transaction do?"

Claude Sonnet 4 processes query:

Extracts intent (safety check, explanation, advice)

If transaction/address provided â†’ Runs analysis

Generates conversational response

Response includes:

Plain English explanation

Specific risks identified

Actionable recommendation

Links to learn more

Conversation history saved

Acceptance Criteria:

 Understands 95%+ of security queries

 Responses in <3 seconds

 Explanations understandable to beginners

 Handles follow-up questions

 Conversation persists across sessions

Feature 8: Exploit Pattern Database
As a SecurityGuard AI agent
I want access to comprehensive exploit patterns
So that I can accurately detect malicious transactions

Technical Implementation:

Database contains:

Known malicious program IDs

Wallet drainer signatures

Rug pull patterns (liquidity removal, authority changes)

Phishing contract indicators

Suspicious account behaviors

Updated daily from:

Blockchain security reports

Community submissions

On-chain analysis

Security research feeds

Pattern matching algorithm:

Exact match: Program ID in blacklist

Fuzzy match: Similar instruction patterns

Behavioral: Multiple red flags combined

Machine learning model trained on:

10,000+ confirmed exploits

100,000+ safe transactions

Continuously updated with new data

Acceptance Criteria:

 Database contains 10M+ patterns

 Updated daily automatically

 Query time <100ms

 99.8%+ detection accuracy

 0.5% false positive rate

 Community can submit new patterns

Phase 3: Advanced Features (Post-MVP)
Feature 9: Natural Language Agent Hiring
As a non-technical user
I want to describe my need in plain English
So that I can hire agents without understanding blockchain complexity

Technical Implementation:

Homepage chat interface

User types: "I need someone to analyze this smart contract for bugs"

AI processes request:

Extracts intent: Code audit service

Identifies required capability: Smart Contract Audit

Searches marketplace for matching agents

Ranks by: reputation, price, availability

Recommends top 3 agents with reasoning

User selects recommended agent

AI guides through:

"I'll hire CodeAudit AI for you. It costs 0.5 SOL. Connect your wallet to continue."

Handles wallet connection

Processes payment

Submits service request

Explains results when complete

Acceptance Criteria:

 Interprets 90%+ of natural language requests

 Recommends appropriate agents

 Handles entire hiring flow conversationally

 Explains blockchain actions in simple terms

 Works for all agent types

Feature 10: Multi-Agent Workflows
As a power user
I want to chain multiple agents together
So that I can complete complex tasks automatically

Technical Implementation:

Workflow builder interface (drag-and-drop)

Example workflow:

SecurityGuard scans contract

If safe â†’ CodeCraft deploys it

YieldHunter monitors performance

DataOracle generates weekly reports

User defines:

Sequence of agents

Conditional logic (if/then)

Data passing between agents

Payment budget

Workflow saved as smart contract

Executes automatically when triggered

Progress notifications in real-time

Acceptance Criteria:

 Supports 5+ agent chains

 Visual workflow builder

 Conditional logic works

 Data passes correctly between agents

 Budget controls prevent overspending

 Can be scheduled or event-triggered

SMART CONTRACT SPECIFICATIONS
Contract 1: Agent Registry
rust
// Program: agent_registry

#[account]
pub struct AgentProfile {
    pub agent_id: Pubkey,           // Unique agent identifier
    pub creator: Pubkey,            // Creator wallet address
    pub name: String,               // Agent name (max 50 chars)
    pub description: String,        // Description (max 500 chars)
    pub capabilities: Vec<u8>,      // Capability flags (bitfield)
    pub pricing_model: PricingModel,
    pub endpoint_url: String,       // API endpoint for agent execution
    pub ipfs_hash: String,          // Agent code/model on IPFS
    pub reputation_score: u32,      // Average rating * 100
    pub total_services: u64,        // Total completed services
    pub total_earnings: u64,        // Total earnings in lamports
    pub created_at: i64,            // Unix timestamp
    pub is_active: bool,            // Can receive requests
    pub nft_mint: Pubkey,           // Agent ownership NFT
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub enum PricingModel {
    PerQuery { price: u64 },        // Fixed price per request
    Subscription { monthly: u64 },   // Monthly subscription
    Custom { base: u64, variable: u8 }, // Base + % of value
}

// Instructions
pub fn register_agent(
    ctx: Context<RegisterAgent>,
    name: String,
    description: String,
    capabilities: Vec<u8>,
    pricing: PricingModel,
    endpoint: String,
    ipfs_hash: String,
) -> Result<()>

pub fn update_agent(
    ctx: Context<UpdateAgent>,
    // Updated fields
) -> Result<()>

pub fn deactivate_agent(
    ctx: Context<DeactivateAgent>,
) -> Result<()>
Contract 2: Marketplace Escrow
rust
// Program: marketplace_escrow

#[account]
pub struct ServiceRequest {
    pub request_id: Pubkey,
    pub agent_id: Pubkey,
    pub user: Pubkey,
    pub amount: u64,                // Payment amount in lamports
    pub status: RequestStatus,
    pub request_data: String,       // User's request (IPFS hash)
    pub result_data: String,        // Agent's result (IPFS hash)
    pub created_at: i64,
    pub completed_at: Option<i64>,
    pub escrow_account: Pubkey,     // PDA holding funds
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq)]
pub enum RequestStatus {
    Pending,        // Payment in escrow, awaiting agent
    InProgress,     // Agent working on request
    Completed,      // Result submitted, awaiting user approval
    Approved,       // User approved, payment released
    Disputed,       // User disputed, manual review needed
    Cancelled,      // Request cancelled, refund issued
}

// Instructions
pub fn create_request(
    ctx: Context<CreateRequest>,
    agent_id: Pubkey,
    amount: u64,
    request_data: String,
) -> Result<()>

pub fn submit_result(
    ctx: Context<SubmitResult>,
    request_id: Pubkey,
    result_data: String,
) -> Result<()>

pub fn approve_result(
    ctx: Context<ApproveResult>,
    request_id: Pubkey,
) -> Result<()>  // Releases payment with royalty split

pub fn dispute_result(
    ctx: Context<DisputeResult>,
    request_id: Pubkey,
    reason: String,
) -> Result<()>
Contract 3: Reputation System
rust
// Program: reputation_system

#[account]
pub struct Rating {
    pub rating_id: Pubkey,
    pub agent_id: Pubkey,
    pub user: Pubkey,
    pub request_id: Pubkey,
    pub stars: u8,              // 1-5 stars
    pub quality: u8,            // 1-5
    pub speed: u8,              // 1-5
    pub value: u8,              // 1-5
    pub review_text: String,    // Optional review (IPFS hash)
    pub created_at: i64,
}

// Instructions
pub fn submit_rating(
    ctx: Context<SubmitRating>,
    request_id: Pubkey,
    stars: u8,
    quality: u8,
    speed: u8,
    value: u8,
    review_text: String,
) -> Result<()>  // Also updates AgentProfile.reputation_score

pub fn get_agent_ratings(
    agent_id: Pubkey,
) -> Result<Vec<Rating>>
Contract 4: Royalty Distribution
rust
// Program: royalty_splitter

pub struct RoyaltyConfig {
    pub creator_share: u8,      // 85% (stored as 85)
    pub platform_share: u8,     // 10%
    pub treasury_share: u8,     // 5%
    pub platform_wallet: Pubkey,
    pub treasury_wallet: Pubkey,
}

// Instruction
pub fn distribute_payment(
    ctx: Context<DistributePayment>,
    amount: u64,
    creator: Pubkey,
) -> Result<()>  // Automatically splits payment 85/10/5
AI AGENT SPECIFICATIONS
SecurityGuard AI - Detailed Design
Input Format
json
{
  "transaction": {
    "serialized": "base64_encoded_transaction",
    "instructions": [
      {
        "programId": "program_public_key",
        "accounts": ["account1", "account2"],
        "data": "instruction_data"
      }
    ]
  },
  "user_wallet": "user_public_key"
}
Analysis Pipeline
Step 1: Transaction Parsing

Deserialize transaction

Extract all program IDs

List all accounts involved

Decode instruction data

Step 2: Program Verification

Check each program ID against:

Verified program whitelist

Known malicious program blacklist

New program risk assessment

Flag: Unknown programs, recently deployed, unverified

Step 3: Pattern Matching

Search exploit database for:

Exact instruction matches

Similar patterns (fuzzy matching)

Multi-instruction attack sequences

Check for:

Unlimited token approvals

Authority delegation

Liquidity removal patterns

Suspicious account transfers

Step 4: ML-Based Anomaly Detection

Feed transaction features to ML model:

Program interaction patterns

Account relationship graph

Value flow analysis

Timing indicators

Model outputs:

Anomaly score (0-1)

Classification: Normal / Suspicious / Malicious

Confidence level

Step 5: Account Analysis

Check each account for:

Previous involvement in exploits

Token balance history (red flag: sudden drains)

Creation date (new = higher risk)

Associated known malicious addresses

Step 6: Risk Scoring

Combine all signals:

Blacklist hit = 100 (DANGER)

Unknown program = +20

Suspicious pattern = +30

ML anomaly = +0 to +50

Account red flags = +10 each

Final score: 0-100

0-30: SAFE âœ…

31-70: CAUTION âš ï¸

71-100: DANGER ğŸš¨

Step 7: Natural Language Explanation

Claude Sonnet 4 generates:

Simple explanation of what transaction does

Specific risks identified

Why it's flagged (evidence)

Clear recommendation

Example: "This transaction will give the program unlimited access to your USDC tokens. The program was deployed 2 days ago and matches wallet drainer patterns. DANGER: Do not sign."

Output Format
json
{
  "risk_level": "DANGER",
  "risk_score": 95,
  "explanation": "This contract will drain your wallet...",
  "recommendation": "BLOCK",
  "details": {
    "program_checks": {
      "unknown_programs": 1,
      "blacklisted_programs": 0,
      "verified_programs": 0
    },
    "pattern_matches": [
      "Unlimited token approval",
      "Transfer to unknown address"
    ],
    "ml_analysis": {
      "anomaly_score": 0.92,
      "classification": "Malicious",
      "confidence": 0.98
    },
    "account_flags": [
      "Recipient address is 2 days old",
      "Similar to known scam patterns"
    ]
  },
  "scan_time_ms": 1847
}
Performance Targets
Latency: <2 seconds (95th percentile)

Accuracy: 99.8% detection of known exploits

False Positives: <0.5%

Throughput: 100 scans/second

Uptime: 99.9%

USER INTERFACE DESIGN SPECIFICATIONS
Design System
Colors:

Primary: Solana purple (#9945FF)

Success: Green (#14F195)

Warning: Orange (#FF6B35)

Danger: Red (#F03A47)

Background: Dark (#0F0F0F) / Light (#FFFFFF)

Typography:

Headings: Inter Bold

Body: Inter Regular

Code: JetBrains Mono

Components: shadcn/ui (Radix primitives + TailwindCSS)

Icons: Lucide Icons

Animations: Framer Motion

Key Pages
1. Homepage
Hero section:

Headline: "The AI Agent Marketplace for Web3"

Subheading: "Hire autonomous AI agents for crypto. Create agents and earn forever."

CTA buttons: "Explore Agents" / "Register Your Agent"

Stats bar: Total agents, services completed, total earned

Featured agents carousel

How it works (3-step visual)

Recent activity feed

2. Marketplace
Header: Search bar + filters

Agent grid (responsive: 3 cols desktop, 1 col mobile)

Agent card:

Agent avatar/icon

Name + creator

Capability badges

Rating (stars + count)

Price

"Hire Now" button

Pagination

"No results" state with suggestions

3. Agent Profile
Hero: Agent name, avatar, creator info

Stats: Rating, services, earnings, response time

Capabilities section (visual badges)

Pricing details

Recent reviews (5 latest)

"Hire This Agent" CTA (sticky on scroll)

Similar agents recommendations

4. Service Request Flow
Step 1: Describe your need (text area)

Step 2: Review price and terms

Step 3: Connect wallet

Step 4: Confirm payment

Step 5: Status tracking (progress bar)

Step 6: View result + rate agent

5. Creator Dashboard
Overview cards:

Total earnings (big number + chart)

Active requests (count)

Average rating (stars)

Response time (avg)

Agent performance table

Withdraw earnings button

Request history (filterable)

Analytics charts

6. SecurityGuard Page
Hero: "Protect Yourself Before You Sign"

Two options:

Paste Transaction â†’ Scan button

Chat interface for questions

Result display:

Large risk indicator (SAFE/CAUTION/DANGER with color)

Risk score visualization

Explanation text

Detailed analysis (expandable)

"Scan Another" button

Recent scans history

Stats: Threats blocked, users protected

DEVELOPMENT ROADMAP
Week 1: Foundation (Nov 4-10)
Day 1-2: Setup & Planning
 Create GitHub repository

 Initialize Kiro IDE project

 Write complete requirements.md

 Write detailed design.md

 Write task breakdown (tasks.md)

 Setup Solana development environment

 Initialize Next.js 14 project

 Configure AWS Q Developer integration

Day 3-5: Smart Contracts
 Design contract architecture

 Implement agent_registry contract

 Implement marketplace_escrow contract

 Write unit tests

 Deploy to Solana devnet

 Test contract interactions

Day 6-7: Frontend Foundation
 Setup Next.js with TypeScript

 Configure TailwindCSS + shadcn/ui

 Implement wallet connection

 Create basic layout (navbar, footer)

 Setup routing structure

 Configure environment variables

Week 2: Core Marketplace (Nov 11-17)
Day 8-10: Agent Registration
 Build registration form UI

 Connect to agent_registry contract

 Implement NFT minting

 Test registration flow end-to-end

 Add validation and error handling

Day 11-13: Marketplace UI
 Build agent listing page

 Implement search and filters

 Create agent card components

 Build agent profile pages

 Add pagination

 Connect to on-chain data

Day 14: Service Request Flow
 Build hire agent modal

 Implement escrow payment

 Create status tracking page

 Add webhook system for agent notifications

 Test payment flow

Week 3: SecurityGuard AI (Nov 18-24)
Day 15-17: AI Agent Core
 Setup Python FastAPI backend

 Build transaction parser

 Create exploit pattern database

 Implement pattern matching algorithms

 Setup Claude Sonnet 4 integration

Day 18-20: ML & Analysis
 Train anomaly detection model

 Integrate ML pipeline

 Build risk scoring engine

 Create natural language explanation generator

 Optimize for <2 second response time

Day 21: SecurityGuard UI
 Build SecurityGuard landing page

 Create transaction scan interface

 Build chat interface for questions

 Design result display (risk visualization)

 Add scan history

Week 4: Polish & Demo (Nov 25-Dec 1)
Day 22-23: Integration & Testing
 End-to-end marketplace testing

 SecurityGuard integration testing

 Payment flow verification

 Performance testing (100+ concurrent users)

 Security audit of contracts

 Bug fixing

Day 24: UI/UX Polish
 Refine all page designs

 Add animations and transitions

 Ensure mobile responsiveness

 Optimize loading states

 Add error boundaries

 Accessibility improvements

Day 25: Demo Materials
 Script demo video (3-4 minutes)

 Record screen captures

 Edit video with voiceover

 Create pitch deck (10 slides)

 Write project description

 Take screenshots for submission

Day 26: Documentation
 Write comprehensive README

 Document API endpoints

 Create setup/deployment guide

 Add inline code comments

 Document Kiro IDE usage

 Record AWS Q Developer usage evidence

Day 27: Deployment & Submission
 Deploy contracts to Solana mainnet

 Deploy frontend to AWS Amplify

 Setup production RPC endpoints

 Configure monitoring (CloudWatch)

 Final smoke testing

 Submit to DoraHacks before 11:59 PM PST

KIRO IDE USAGE STRATEGY
How We'll Use Kiro Throughout Development
1. Spec-Driven Development
requirements.md: Complete before any coding

All user stories with EARS notation

Acceptance criteria for each feature

Clear requirements for every component

design.md: Detailed technical architecture

System diagrams

Data models

API specifications

Technology stack decisions

tasks.md: Granular implementation tasks

Each task linked to requirements

Estimated time for each task

Dependencies clearly marked

Progress tracking

2. AWS Q Developer Integration
Use Q Developer for:

Boilerplate code generation from specs

Smart contract scaffolding

API endpoint creation

Test case generation

Documentation writing

Code review and optimization

3. Steering Files
Create .kiro/steering/ folder with context:

project-context.md: High-level project overview

architecture.md: System architecture details

coding-standards.md: Code style and patterns

security-guidelines.md: Security best practices

testing-strategy.md: Testing requirements

4. Continuous Documentation
Document every major decision

Update specs as requirements evolve

Keep design.md in sync with implementation

Track completed tasks in tasks.md

Use Q Developer to generate docs

5. Evidence Collection
Throughout development, collect:

Screenshots of Kiro IDE in use

Examples of Q Developer generations

Before/after code improvements

Spec â†’ Implementation examples

This proves Kiro IDE usage for judges

SUBMISSION CHECKLIST
Required Deliverables
1. Working Demo
 Live URL: https://agentmarket.vercel.app

 Deployed on Solana mainnet (or devnet)

 All core features functional

 Mobile responsive

 No critical bugs

2. Demo Video (3-5 minutes)
 Uploaded to YouTube/Vimeo

 Problem statement (0:30)

 Solution walkthrough (2:00)

 Technical highlights (0:30)

 Kiro IDE usage showcase (0:30)

 Impact and vision (0:30)

 Professional quality (clear audio, good editing)

3. GitHub Repository
 Public repository

 Complete source code

 .kiro/ folder with requirements.md, design.md, tasks.md

 Comprehensive README

 Setup instructions

 License (MIT or Apache 2.0)

 Clean commit history

4. Documentation
 README with:

Project description

Features list

Tech stack

Setup guide

Deployment guide

Kiro IDE usage explanation

AWS Q Developer usage examples

 API documentation

 Smart contract documentation

 Architecture diagrams

5. DoraHacks Submission Form
 Project name: AgentMarket

 Tagline: "The First Decentralized AI Agent Marketplace"

 Description: (compelling 200-word pitch)

 Track: Web3 AI Integration

 Demo URL

 Video URL

 GitHub URL

 Team information

 Kiro IDE usage description

 Impact statement

WINNING STRATEGY SUMMARY
Why This Project Will Win Grand Prize
Innovation (25 points)
âœ… First AI agent marketplace on Solana - Category creation
âœ… Novel economic model - Creators earn forever via royalties
âœ… Dual value proposition - Platform + Utility agent
âœ… Future-forward - Positioned for AI agent economy explosion

Technical Excellence (25 points)
âœ… Full-stack complexity - Smart contracts + AI + Frontend
âœ… Perfect Kiro IDE showcase - Complete spec-driven development
âœ… Advanced AI integration - ML models + Natural language + Real-time analysis
âœ… Solana native - Leverages speed and low fees

Real-world Impact (20 points)
âœ… Solves $2B problem - Prevents wallet exploits
âœ… Empowers creators - New income stream for AI builders
âœ… Accessible to all - No technical knowledge required
âœ… Open source - Benefits entire ecosystem

User Experience (15 points)
âœ… Beautiful UI - Consumer-grade polish
âœ… Intuitive flow - One-click agent hiring
âœ… Natural language - Chat with AI in plain English
âœ… Mobile ready - Works on all devices

Sustainability (15 points)
âœ… Clear business model - 10% marketplace fee
âœ… Network effects - Value grows with adoption
âœ… Realistic roadmap - MVP â†’ Growth â†’ Scale
âœ… VC interest - Marketplace model is fundable